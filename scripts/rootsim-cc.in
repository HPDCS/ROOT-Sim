#!/bin/bash
#
# ROOT-Sim CC - Copyright (C) HPDCS Group @ Sapienza, University of Rome
# Released under the GNU GPL v3
#
# CHANGELOG:
#   22 sep 2012 - Alessandro Pellegrini <pellegrini@dis.uniroma1.it>
#	Created the first version of this script
#   10 apr 2019 - Alessandro Pellegrini <pellegrini@dis.uniroma1.it>
#       Instrumentation is now carried out using gcc plugin
#
# ROOT-Sim CC: this is just a gcc/mpicc wrapper which follows through the
# various steps in order to correctly compile a simulation model against
# the static ROOT-Sim Library


##############################################################################
# Global configuration variables
##############################################################################
CC="@CC@"
CFLAGS="@CFLAGS@"
VERSION="@VERSION@"
bindir="@bindir@"
libdir="@libdir@"
includedir="@includedir@"
datadir="@datadir@"
iss_support="@iss_support@"
pmu_support="@pmu_support@"
SCRIPT_LINES="@scriptlines@"
LD_DATA1_LINES="@lddata1lines@"
LD_DATA2_LINES="@lddata2lines@"
LD_FINAL_LINES="@ldfinallines@"


##############################################################################
# Handle temporary files
##############################################################################
generate_linker_scripts()
{
START_LINES=$SCRIPT_LINES
(( START_LINES += 1 ))
tail -n +$START_LINES "$0" | head -n +$LD_DATA1_LINES > $$.ld-data1
(( START_LINES += $LD_DATA1_LINES ))
tail -n +$START_LINES "$0" | head -n +$LD_DATA2_LINES > $$.ld-data2
(( START_LINES += $LD_DATA2_LINES ))
tail -n +$START_LINES "$0" | head -n +$LD_FINAL_LINES > $$.ld-final
}

build_cleanup()
{
rm $$.ld-data1
rm $$.ld-data2
rm $$.ld-final
rm -f ${SOURCES//.c/.o}
rm -f ${SOURCES//.c/.o.rs}
rm -f APP*.o
rm -f original
}


##############################################################################
# Check for termination of the intermediate steps, if failed cleanup the system
##############################################################################
check_term()
{
if [ $? -ne 0 ]; then
	build_cleanup
	exit 1
fi
}


##############################################################################
# The ROOT-Sim CC script begins here
##############################################################################
CC="$CC -L $libdir -I $includedir"   # This is how we will call the compiler.
LD=ld
PARTIAL=0
OUTNAME=a.out
SOURCES=

next_in_cflags="no"
next_in_outname="no"
for word in "$@"
do
	case "$word" in
		-c)
			if [[ $PARTIAL = 0 ]]; then
				CFLAGS="$CFLAGS -c"
				PARTIAL=1
			fi
			;;
		-o)
			next_in_outname="yes"
			;;
		-MT)
			CFLAGS="$CFLAGS -MT"
			next_in_cflags="yes"
			;;
		-L)
			CFLAGS="$CFLAGS -L"
			next_in_cflags="yes"
			;;
		-MF)
			CFLAGS="$CFLAGS -MF"
			next_in_cflags="yes"
			;;
		*)
			if [ "$next_in_cflags" = "yes" ]; then
				CFLAGS="$CFLAGS $word"
				next_in_cflags="no"
			elif [ "$next_in_outname" = "yes" ]; then
				OUTNAME="$word"
				next_in_outname="no"
			elif [ "${word:0:1}" = "-" ]; then
				CFLAGS="$CFLAGS $word"
			else
				SOURCES="$SOURCES $word"
			fi
			;;
	esac
done


# Check if no source file was specified
if [ ! -n "$SOURCES" ]; then
	echo "No source files specified."
	exit 1
fi


# If partial compilation is invoked, simply call the compiler.
# -c is actually included into CFLAGS
if [[ $PARTIAL = 1 ]]; then
	$CC $CFLAGS $SOURCES -o $OUTNAME
	exit 0
fi


# Generate linker scripts
generate_linker_scripts

OBJECTS=${SOURCES//.c/.o}

if test "$iss_support" = "xyes" -a "$pmu_support" = "xno"
then

	### INSTRUMENTED VERSION OF THE EXECUTABLE
	for f in $SOURCES; do
		if [ "${f: -2:2}" = ".o" ]; then
			mv $f $f.rs
		else
			$CC -fplugin=$libdir/libmemtrace.so -fplugin-arg-libmemtrace-instrument-mode="w" -fplugin-arg-libmemtrace-function-suffix="instr" $CFLAGS -c $f -o ${f/.c/.o.rs}
		fi
		check_term
	done

	# Link together
	$LD -r ${OBJECTS//.o/.o.rs} -o APP.o
	check_term

	# Use a custom linker script to finish mangling the object
	$LD -r -T $$.ld-data1 APP.o -o APP-resectioned.o
	check_term

	cp APP-resectioned.o incremental.foo


	# Link againts DyMeLoR
	$LD -r -L $libdir --wrap strcpy\
			  --wrap strncpy\
			  --wrap strcat\
			  --wrap strncat\
			  --wrap memcpy\
			  --wrap memmove\
			  --wrap memset\
			  --wrap bzero\
			  --wrap strdup\
			  --wrap strndup\
			  --wrap malloc\
			  --wrap free\
			  --wrap realloc\
			  --wrap calloc -o APP-instr.o APP-resectioned.o --whole-archive -ldymelor
	check_term

	rm ${OBJECTS//.o/.o.rs}
fi

### NON-INSTRUMENTED VERSION OF THE EXECUTABLE
for f in $SOURCES; do
	if [ "${f: -2:2}" = ".o" ]; then
		mv $f $f.rs
	else
		$CC $CFLAGS -c $f -o ${f/.c/.o.rs}
	fi
	check_term
done

$LD -r ${OBJECTS//.o/.o.rs} -o APP.o

# Use a custom linker script to finish mangling the object
$LD -r -T $$.ld-data2 APP.o -o APP-resectioned.o
check_term

cp APP-resectioned.o non-incremental.foo

# Incremental linking non-instrumented version
$LD -r -L $libdir --wrap strcpy\
		  --wrap strncpy\
		  --wrap strcat\
		  --wrap strncat\
		  --wrap memcpy\
		  --wrap memmove\
		  --wrap memset\
		  --wrap bzero\
		  --wrap strdup\
		  --wrap strndup\
		  --wrap malloc\
		  --wrap free\
		  --wrap realloc\
		  --wrap calloc -o APP-non-instr.o APP-resectioned.o --whole-archive -ldymelor
check_term

if test "$iss_support" = "xyes"
then
	# Merge the two relocatable objects together and finish generating the application
	$LD -r -z muldefs APP-non-instr.o APP-instr.o -o APP-final.o
	cp APP-final.o mixed.foo
	$CC -Xlinker -T -Xlinker $$.ld-final APP-final.o $CFLAGS -lrootsim -lm -o $OUTNAME
	check_term
else
	# Only one version of the executable is available
	$CC -Xlinker -T -Xlinker $$.ld-final APP-non-instr.o $CFLAGS -lrootsim -lm -o $OUTNAME
	check_term
fi

# Clean temporary files
build_cleanup

exit 0

# Raw linker scripts start here!
